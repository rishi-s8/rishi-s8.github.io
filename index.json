[{"authors":["admin"],"categories":null,"content":"Rishi Sharma is a Final year undergraduate student in the School of Computing and Electrical Engineering (SCEE) at Indian Institute of Technology Mandi, majoring in Computer Science and Engineering. His research interests include performance optimization of computer programs, algorithmic differentiation, machine learning \u0026amp; deep learning and satisfiability checking. He is the founder and coordinator of Heuristics IIT Mandi, which is a group of people collaborating and hosting sessions on research topics for the students of the institute.\nRishi has completed his winter semester 2019-2020 at RWTH Aachen University Germany as part of the Student Exchange Programme, where he indulged in Masters-level courses and Research Assistant jobs with IT-Security group and Theory of Hybrid Systems group.\nRishi is currently working with Dr. Manas Thakur in the Compilers and Programming Languages Group at IIT Mandi for his final-year Major Technical Project (September 2020 - June 2021) on Enabling Concurrency via Program Analysis.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1602140928,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://rishi-s8.github.io/author/rishi-sharma/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/rishi-sharma/","section":"authors","summary":"Rishi Sharma is a Final year undergraduate student in the School of Computing and Electrical Engineering (SCEE) at Indian Institute of Technology Mandi, majoring in Computer Science and Engineering. His research interests include performance optimization of computer programs, algorithmic differentiation, machine learning \u0026amp; deep learning and satisfiability checking.","tags":null,"title":"Rishi Sharma","type":"authors"},{"authors":null,"categories":null,"content":"","date":1601942400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1602143375,"objectID":"1b1ce8349db679fa8437b04108c0d2f9","permalink":"https://rishi-s8.github.io/project/distributed-gaming/","publishdate":"2020-10-06T00:00:00Z","relpermalink":"/project/distributed-gaming/","section":"project","summary":"A Distributed Implementation of Pong using Go and Kafka","tags":null,"title":"Distributed Gaming","type":"project"},{"authors":null,"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including [code and math](https://sourcethemes.com/academic/docs/writing-markdown-latex/). -- ","date":1590105600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1602147778,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://rishi-s8.github.io/publication/preprint/","publishdate":"2020-05-22T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"This paper presents EinsteinPy (version 0.3), a community-developed Python package for gravitational and relativistic astrophysics. Python is a free, easy to use a high-level programming language which has seen a huge expansion in the number of its users and developers in recent years. Specifically, a lot of recent studies show that the use of Python in Astrophysics and general physics has increased exponentially. We aim to provide a very high level of abstraction, an easy to use interface and pleasing user experience. EinsteinPy is developed keeping in mind the state of a theoretical gravitational physicist with little or no background in computer programming and trying to work in the field of numerical relativity or trying to use simulations in their research. Currently, EinsteinPy supports simulation of time-like and null geodesics and calculates trajectories in different background geometries some of which are Schwarzschild, Kerr, and KerrNewmann along with coordinate inter-conversion pipeline. It has a partially developed pipeline for plotting and visualization with dependencies on libraries like Plotly, matplotlib, etc. One of the unique features of EinsteinPy is a sufficiently developed symbolic tensor manipulation utilities which are a great tool in itself for teaching yourself tensor algebra which for many beginner students can be overwhelmingly tricky. EinsteinPy also provides few utility functions for hypersurface embedding of Schwarzschild spacetime which further will be extended to model gravitational lensing simulation.","tags":null,"title":"EinsteinPy: A Community Python Package for General Relativity","type":"publication"},{"authors":["Rishi Sharma"],"categories":["Tutorials"],"content":"Differentiation is easy, right? I always thought so. But then came complex derivatives in the form of Backpropagation and Backpropagation through Time. If you also think differentiation is easy, I urge you to try out deriving Backpropagation through Time before reading ahead.\nIn this blog, I shall walk you through modelling mathematical functions as Directed Acyclic Graphs, and then finding their derivatives. This is something I learned as part of the course Computational Differentiation at RWTH Aachen University, taught by Prof. Uwe Naumann. This method made it extremely easy to derive Backpropagation algorithms in Deep Learning.\nLet us start by recalling the chain rule of differentiation once.\n$$y = \\mathbf{f}(\\mathbf{g}(x))$$ $$\\frac{dy}{dx} = \\frac{d\\mathbf{f}(\\mathbf{g})}{d\\mathbf{g}} \\cdot \\frac{d\\mathbf{g}(x)}{dx}$$\nNow, try deriving the following:\n$$y = x \\cdot e^{sin(x)}$$\nHow do Directed Acyclic Graphs come into the picture?\nA Directed Acyclic Graph can be used to graphically represent the computation of a mathematical function. Each node of the graph represents an elementary computation. Edges represent the flow of computations.\nWe shall start by reducing the function given above into elementary computations known as Single Assignment Code.\nSingle Assignment Code A SAC of a mathematical function is a multi-step computation, where in each step, only one elementary computation may be performed. A single application of +, -, *, /, log, exp, sin, cos etc. may be termed as an elementary computation.\nFor example, $$y = x \\cdot e^{sin(x)}$$\nThe Single Assignment Code for this function: $$v_1 = sin(x)$$ $$v_2 = e^{v_1}$$ $$y = x \\cdot v_2$$\nDrawing a DAG is pretty simple once we have the SAC for the function. Each assignment in the SAC is a node in the DAG. The edges shall be directed from the inputs to the outputs for each assignment.\n  The Directed Acyclic Graph generated from the Single Assignment Code for the function y=x*exp(sin(x)).   As one can notice from the graph, the whole computation is embedded in the graph itself. This means we can compute the result of the function for a certain value of input from the DAG without actually looking at the mathematical form of the function. This DAG is also know as the Computational Graph of the given function.\nEnter Derivatives! Since we have the computational graph of the function, we just need a slight tweak to the graph to help us get the derivative. Label each edge with the partial derivative of the output node for that edge with respect to the input node for the edge. Notice the word PARTIAL. Since each node is an elementary computation, there is no chain rule involved in computing this derivative.\n  The Directed Acyclic Graph with edges labelled with derivatives for the function y=x*exp(sin(x)).   Derivative of the function from the Computational Graph Assume we have two nodes i and j in the graph, and there exists a path from i to j. To compute the derivative of j with respect to i, do the following:\n Traverse each path k from node i to node j in the computational graph and compute the product of the value on each edge on the path. Call it pk. Compute the sum of the values of pk for all such paths from i to j.  For our example, we need to compute the derivative of y with respect to x. Traversing the path on the top in the graph, $$p_1 = \\frac{\\partial y}{\\partial x} = v_2$$\nTraversing the path at the lower end, $$p_2 = \\frac{\\partial v_1}{\\partial x} \\cdot \\frac{\\partial v_2}{\\partial v_1} \\cdot \\frac{\\partial y}{\\partial v_2} = cos(x) \\cdot e^{v_1} \\cdot x$$\nSo, the required derivative becomes $$\\frac{\\partial y}{\\partial x} = p_1 + p_2$$ $$\\frac{\\partial y}{\\partial x} = (v_2) + (cos(x) \\cdot e^{v_1} \\cdot x)$$ $$\\frac{\\partial y}{\\partial x} = (v_2) + (cos(x) \\cdot e^{v_1} \\cdot x)$$ Substituting the values from the SAC, $$\\frac{\\partial y}{\\partial x} = (e^{v_1}) + (cos(x) \\cdot e^{sin(x)} \\cdot x)$$ $$\\frac{\\partial y}{\\partial x} = (e^{sin(x)}) + (cos(x) \\cdot e^{sin(x)} \\cdot x)$$.\nSimple right? Isn\u0026rsquo;t it the same thing you get when applying chain rule directly? In fact, whatever we did in the form of Single Assignment Code, Computational Graph and then summing the product of each path was basically the chain rule. I\u0026rsquo;d leave it to you to think why this actually works. I\u0026rsquo;d be happy to discuss this personally.\nAnswer this. What would happen if there is no path from input to output?\nConclusion We saw how to model computations in the form of computational graphs and compute derivative of any differentiable function. Now, you must be thinking why go through all this when you could directly apply Chain-rule and get the answer? The simple answer is do what is easier. For simple functions, directly applying chain-rule is easier. For, more complex, multi-dimensional functions, Computational Graphs make life super-simple. With a little practice, you can directly jump to drawing the DAG without explicitly using the Single Assignment Code.\nTake some complicated functions and try finding the derivatives using the computational graph.\nFinally, there are some problems where you are directly given the Computational Graph and you need to find the derivative. The best examples are Multi-layer Perceptrons and Recurrent Neural Networks. It is quite tedious to derive the backpropagation algorithms for these. Now, using the computational graph (in this case, the architecture diagram itself), we can easily derive the backpropagation algorithm. I urge you to try it out. I\u0026rsquo;ll discuss these in a later tutorial.\nThank you for reading. Please let me know what you think about the post. :)\n","date":1588982400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589099059,"objectID":"7a97f15bd94b931c4d64a2aacea58b72","permalink":"https://rishi-s8.github.io/post/differentiation-dag/","publishdate":"2020-05-09T00:00:00Z","relpermalink":"/post/differentiation-dag/","section":"post","summary":"Using DAGs to find the derivatives of complex functions.","tags":["Differentiation","Computational Differentiation","DAGs"],"title":"Simplifying Differentiation using Directed Acyclic Graphs","type":"post"},{"authors":null,"categories":null,"content":"","date":1582156800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1602148142,"objectID":"14e4747460029ff8de6252d3df76df40","permalink":"https://rishi-s8.github.io/project/sparkyad/","publishdate":"2020-02-20T00:00:00Z","relpermalink":"/project/sparkyad/","section":"project","summary":"Apache Spark based Parallel Implementation of Tangent Mode Automatic Differentation","tags":null,"title":"SparkyAD","type":"project"},{"authors":null,"categories":null,"content":"","date":1577232000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577232000,"objectID":"c0b1afc0916ab2d7a7d304f641f7b7ae","permalink":"https://rishi-s8.github.io/project/cnf-crack/","publishdate":"2019-12-25T00:00:00Z","relpermalink":"/project/cnf-crack/","section":"project","summary":"A C++ Implementation of SAT Solver","tags":null,"title":"CNFCrack","type":"project"},{"authors":null,"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including [code and math](https://sourcethemes.com/academic/docs/writing-markdown-latex/). -- ","date":1575158400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1602147778,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://rishi-s8.github.io/publication/conference-paper/","publishdate":"2019-12-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Air-quality is degrading in developing countries and there is an urgent need to monitor and predict air-quality online in real-time. Although offline air-quality monitoring using hand-held devices is common, online air-quality monitoring is still expensive and uncommon, especially in developing countries. The primary objective of this paper is to propose an online low-cost air-quality monitoring, prediction, and warning system (AQMPWS) which monitors, predicts, and warns about air-quality in real-time. The AQMPWS monitors and predict seven pollutants, namely, PM1.0, PM2.5, PM10, Carbon Monoxide, Nitrogen Dioxide, Ozone and Sulphur Dioxide. In addition, the AQMPWS monitors and predicts five weather variables, namely, Temperature, Pressure, Relative Humidity, Wind Speed, and Wind Direction. The AQMPWS has its sensors connected to two microcontrollers in a Master-Slave configuration. The slave sends the data to the API in the cloud through an HTTP GET request via a GSM Module. A python-based web-application interacts with the API for visualization, prediction, and warning. Results show that the AQMPWS monitor different pollutants and weather variables within range specified by pollution control board. In addition, the AQMPWS predict the value of the pollutants and weather variables for the next 30-min given the current values of these pollutants and weather variables using an ensemble model containing a multilayer-perceptron and long short-term memory model. The AQMPWS is also able to warn stakeholders when any of the seven pollutants breach pre-defined thresholds. We discuss the implications of using AQMPWS for air-quality monitoring in the real-world.","tags":null,"title":"An Online Low-Cost System for Air Quality Monitoring, Prediction, and Warning ","type":"publication"},{"authors":["Rishi Sharma"],"categories":["Editorials"],"content":"","date":1562630400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589096143,"objectID":"59d0ca1ecdcc7700c97ca4626c77cb8e","permalink":"https://rishi-s8.github.io/post/wtf-editorial/","publishdate":"2019-07-09T00:00:00Z","relpermalink":"/post/wtf-editorial/","section":"post","summary":"Editorials for What the Flag 2019.","tags":["CTF"],"title":"What the Flag (WTF) 2019 Editorial","type":"post"}]